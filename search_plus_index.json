{"./":{"url":"./","title":"Introduction","keywords":"","body":"Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2021-01-13 10:29:47 "},"doc/start.html":{"url":"doc/start.html","title":"dubbo基础","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 dubbo基础 dubbo框架 调用链 & 领域模型 dubbo源码模拟 SPI dubbo增强的SPI 源码流程 服务目录(ListInvoker) 服务目录类继承体系 AbstractDirectory RegistryDirectory 服务路由 集群 FailoverClusterInvoker doInvoke(选择invoker，执行invoke调用) select(通过负载均衡选择invoker) 负载均衡 RandomLoadBalance（随机加权，默认使用） LeastActiveLoadBalance（最小活跃数） ConsistentHashLoadBalance（一致性 hash） RoundRobinLoadBalance（轮询） Dubbo 通信协议和序列化 通信协议 序列化协议 服务降级 常见面试题 Dubbo内置了哪几种服务容器？ Dubbo默认使用什么注册中心，还有别的选择吗？ Dubbo 核心的配置有哪些？ 配置覆盖关系? 在 Provider 上可以配置的 Consumer 端的属性有哪些？ Dubbo启动时如果依赖的服务不可用会怎样？ 注册了多个同一样的服务，如果测试指定的某一个服务呢？ Dubbo服务之间的调用是阻塞的吗？ 服务提供者能实现失效踢出是什么原理？ 服务读写推荐的容错策略是怎样的？ dubbo基础 Dubbo 源代码分析系列 dubbo框架 服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。 配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为中心，可以直接new配置类，也可以通过spring解析配置生成配置类。 服务代理层（Proxy）：服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton，以ServiceProxy为中心，扩展接口为ProxyFactory。 服务注册层（Registry）：封装服务地址的注册与发现，以服务URL为中心，扩展接口为RegistryFactory、Registry和RegistryService。可能没有服务注册中心，此时服务提供方直接暴露服务。 集群层（Cluster）：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster、Directory、Router和LoadBalance。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。 监控层（Monitor）：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。 远程调用层（Protocol）：封将RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。Protocol是服务域，它是Invoker暴露和引用的主功能入口，它负责Invoker的生命周期管理。Invoker是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。 信息交换层（Exchange）：封装请求响应模式，同步转异步，以Request和Response为中心，扩展接口为Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer。 网络传输层（Transport）：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec。 数据序列化层（Serialize）：可复用的一些工具，扩展接口为Serialization、 ObjectInput、ObjectOutput和ThreadPool。 调用链 & 领域模型 在 Dubbo 的核心领域模型中： Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。 Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。 Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等。 dubbo源码模拟 https://github.com/doctording/dubbo-study SPI dubbo spi文档 SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。SPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。 SPI可以理解为：是\"基于接口的编程 + 策略模式 + 配置文件\"组合实现的动态加载机制 Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI的相关逻辑被封装在了ExtensionLoader类中，通过 ExtensionLoader，我们可以加载指定的实现类，使用如下 public class DubboSPITest { @Test public void sayHello() throws Exception { ExtensionLoader extensionLoader = ExtensionLoader.getExtensionLoader(Robot.class); Robot optimusPrime = extensionLoader.getExtension(\"optimusPrime\"); optimusPrime.sayHello(); Robot bumblebee = extensionLoader.getExtension(\"bumblebee\"); bumblebee.sayHello(); } } META-INF/dubbo optimusPrime = org.apache.spi.OptimusPrime bumblebee = org.apache.spi.Bumblebee 首先通过 ExtensionLoader 的 getExtensionLoader 方法获取一个 ExtensionLoader 实例（接口的ExtensionLoader对象） 然后再通过 ExtensionLoader 的 getExtension 方法获取拓展类对象（接口的某个具体实现类实例，主要通过反射实现） private T createExtension(String name) { // 从配置文件中加载所有的拓展类，可得到“配置项名称”到“配置类”的映射关系表 Class clazz = getExtensionClasses().get(name); if (clazz == null) { throw findException(name); } try { T instance = (T) EXTENSION_INSTANCES.get(clazz); if (instance == null) { // 通过反射创建实例 EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance()); instance = (T) EXTENSION_INSTANCES.get(clazz); } // 向实例中注入依赖 injectExtension(instance); Set> wrapperClasses = cachedWrapperClasses; if (wrapperClasses != null && !wrapperClasses.isEmpty()) { // 循环创建 Wrapper 实例 for (Class wrapperClass : wrapperClasses) { // 将当前 instance 作为参数传给 Wrapper 的构造方法，并通过反射创建 Wrapper 实例。 // 然后向 Wrapper 实例中注入依赖，最后将 Wrapper 实例再次赋值给 instance 变量 instance = injectExtension( (T) wrapperClass.getConstructor(type).newInstance(instance)); } } return instance; } catch (Throwable t) { throw new IllegalStateException(\"...\"); } } dubbo增强的SPI Dubbo 的扩展点加载是基于JDK 标准的 SPI 扩展点发现机制增强而来的，Dubbo 改进了 JDK 标准的 SPI 的以下问题： JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。 如果扩展点加载失败，就失败了，给用户没有任何通知。比如：JDK 标准的ScriptEngine，如果Ruby ScriptEngine 因为所依赖的 jruby.jar 不存在，导致 Ruby ScriptEngine 类加载失败，这个失败原因被吃掉了，当用户执行 ruby 脚本时，会报空指针异常，而不是报Ruby ScriptEngine不存在。 增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点 源码流程 public static ExtensionLoader getExtensionLoader(Class type) { /* type 类型不能为null, 必须是接口，必须有@SPI注解 先从ConcurrentMap, ExtensionLoader> EXTENSION_LOADERS 取 否则new ExtensionLoader,放到 EXTENSION_LOADERS 中，然后再获取到 */ if (type == null) { throw new IllegalArgumentException(\"Extension type == null\"); } else if (!type.isInterface()) { throw new IllegalArgumentException(\"Extension type(\" + type + \") is not interface!\"); } else if (!withExtensionAnnotation(type)) { throw new IllegalArgumentException(\"Extension type(\" + type + \") is not extension, because WITHOUT @\" + SPI.class.getSimpleName() + \" Annotation!\"); } else { ExtensionLoader loader = (ExtensionLoader)EXTENSION_LOADERS.get(type); if (loader == null) { EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader(type)); loader = (ExtensionLoader)EXTENSION_LOADERS.get(type); } return loader; } } ExtensionLoader一个构造方法 private ExtensionLoader(Class type) { this.type = type; this.objectFactory = type == ExtensionFactory.class ? null : (ExtensionFactory)getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension(); } 先构造ExtensionFactory(扩展点工厂)，放到map结构中 ExtensionFactory objectFactory: 依赖注入，对象工厂（eg:AdaptiveExtensionFactory） objectFactory变量的类型为AdaptiveExtensionFactory，AdaptiveExtensionFactory内部维护了一个ExtensionFactory列表，用于存储其他类型的 ExtensionFactory。Dubbo 目前提供了两种 ExtensionFactory，分别是SpiExtensionFactory和SpringExtensionFactory。前者用于创建自适应的拓展，后者是用于从 Spring 的 IOC 容器中获取所需的拓展。 接着：Dog dog1 = extensionLoader.getExtension(\"dog1\"); name -> 配置文件 -> 实现类 -> 实例对象 -> 依赖注入(IOC) -> AOP -> 最后返回的完整对象 ConcurrentMap> cachedInstances volatile + double check 执行createExtension(name); 实例对象通过clazz.newInstance()即反射实例化instance出来，然后会执行injectExtension(instance) private T injectExtension(T instance) { try { if (this.objectFactory != null) { Method[] arr$ = instance.getClass().getMethods(); int len$ = arr$.length; for(int i$ = 0; i$ 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : \"\"; // 继续getExtension,然后set到instance中，完成依赖注入 Object object = this.objectFactory.getExtension(pt, property); if (object != null) { method.invoke(instance, object); } } catch (Exception var9) { logger.error(\"fail to inject via method \" + method.getName() + \" of interface \" + this.type.getName() + \": \" + var9.getMessage(), var9); } } } } } catch (Exception var10) { logger.error(var10.getMessage(), var10); } return instance; } 依赖注入完成，接着是aop的实现，最终返回一个包装类的实例 private T createExtension(String name) { Class clazz = (Class)this.getExtensionClasses().get(name); if (clazz == null) { throw this.findException(name); } else { try { T instance = EXTENSION_INSTANCES.get(clazz); if (instance == null) { EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance()); instance = EXTENSION_INSTANCES.get(clazz); } this.injectExtension(instance); Set> wrapperClasses = this.cachedWrapperClasses; Class wrapperClass; if (wrapperClasses != null && wrapperClasses.size() > 0) { /* 循环创建 Wrapper 实例 将当前 instance 作为参数传给 Wrapper 的构造方法，并通过反射创建 Wrapper 实例。 然后向 Wrapper 实例中注入依赖，最后将 Wrapper 实例再次赋值给 instance 变量 */ for(Iterator i$ = wrapperClasses.iterator(); i$.hasNext(); instance = this.injectExtension(wrapperClass.getConstructor(this.type).newInstance(instance))) { wrapperClass = (Class)i$.next(); } } return instance; } catch (Throwable var7) { throw new IllegalStateException(\"Extension instance(name: \" + name + \", class: \" + this.type + \") could not be instantiated: \" + var7.getMessage(), var7); } } } 服务目录(List) 服务目录 服务目录中存储了一些和服务提供者有关的信息，通过服务目录，服务消费者可获取到服务提供者的信息，比如 ip、端口、服务协议等。通过这些信息，服务消费者就可通过 Netty 等客户端进行远程调用。 在一个服务集群中，服务提供者数量并不是一成不变的，如果集群中新增了一台机器，相应地在服务目录中就要新增一条服务提供者记录。或者，如果服务提供者的配置修改了，服务目录中的记录也要做相应的更新。如果这样说，服务目录和注册中心的功能不就雷同了吗？确实如此，这里这么说是为了方便大家理解。实际上服务目录在获取注册中心的服务配置信息后，会为每条配置信息生成一个 Invoker 对象，并把这个 Invoker 对象存储起来，这个 Invoker 才是服务目录最终持有的对象。Invoker 有什么用呢？看名字就知道了，这是一个具有远程调用功能的对象。讲到这大家应该知道了什么是服务目录了，它可以看做是 Invoker 集合，且这个集合中的元素会随注册中心的变化而进行动态调整。 服务目录类继承体系 如上，Directory 继承自 Node 接口，Node 这个接口继承者比较多，像 Registry、Monitor、Invoker 等均继承了这个接口。这个接口包含了一个获取配置信息的方法 getUrl，实现该接口的类可以向外提供配置信息。另外，大家注意看 RegistryDirectory 实现了 NotifyListener 接口，当注册中心节点信息发生变化后，RegistryDirectory 可以通过此接口方法得到变更信息，并根据变更信息动态调整内部 Invoker 列表 AbstractDirectory AbstractDirectory 封装了 Invoker 列举流程，具体的列举逻辑则由子类实现，这是典型的模板模式 public List> list(Invocation invocation) throws RpcException { if (destroyed) { throw new RpcException(\"Directory already destroyed...\"); } // 调用 doList 方法列举 Invoker，doList 是模板方法，由子类实现 List> invokers = doList(invocation); // 获取路由 Router 列表 List localRouters = this.routers; if (localRouters != null && !localRouters.isEmpty()) { for (Router router : localRouters) { try { // 获取 runtime 参数，并根据参数决定是否进行路由 if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) { // 进行服务路由 invokers = router.route(invokers, getConsumerUrl(), invocation); } } catch (Throwable t) { logger.error(\"Failed to execute router: ...\"); } } } return invokers; } // 模板方法，由子类实现 protected abstract List> doList(Invocation invocation) throws RpcException; Invoker 的列举过程如下 调用 doList 获取 Invoker 列表 根据 Router 的 getUrl 返回值为空与否，以及 runtime 参数决定是否进行服务路由 RegistryDirectory RegistryDirectory 是一种动态服务目录，实现了 NotifyListener 接口。当注册中心服务配置发生变化后，RegistryDirectory 可收到与当前服务相关的变化。收到变更通知后，RegistryDirectory 可根据配置变更信息刷新 Invoker 列表。RegistryDirectory 中有几个比较重要的逻辑， 第一是 Invoker 的列举逻辑 第二是 接收服务配置变更的逻辑 第三是 Invoker 列表的刷新逻辑 服务路由 服务目录在刷新 Invoker 列表的过程中，会通过 Router 进行服务路由，筛选出符合路由规则的服务提供者。 服务路由包含一条路由规则，路由规则决定了服务消费者的调用目标，即规定了服务消费者可调用哪些服务提供者。Dubbo 目前提供了三种服务路由实现，分别为条件路由 ConditionRouter、脚本路由 ScriptRouter 和标签路由 TagRouter；其中条件路由是最常使用的 集群 为了避免单点故障，现在的应用通常至少会部署在两台服务器上。对于一些负载比较高的服务，会部署更多的服务器。这样，在同一环境下的服务提供者数量会大于1。对于服务消费者来说，同一环境下出现了多个服务提供者。这时会出现一个问题，服务消费者需要决定选择哪个服务提供者进行调用。另外服务调用失败时的处理措施也是需要考虑的，是重试呢，还是抛出异常，亦或是只打印异常等。 为了处理这些问题，Dubbo 定义了集群接口 Cluster 以及 Cluster Invoker。集群 Cluster 用途是将多个服务提供者合并为一个 Cluster Invoker，并将这个 Invoker 暴露给服务消费者。这样一来，服务消费者只需通过这个 Invoker 进行远程调用即可，至于具体调用哪个服务提供者，以及调用失败后如何处理等问题，现在都交给集群模块去处理。集群模块是服务提供者和服务消费者的中间层，为服务消费者屏蔽了服务提供者的情况，这样服务消费者就可以专心处理远程调用相关事宜。比如发请求，接受服务提供者返回的数据等。这就是集群的作用。 Dubbo 提供了多种集群实现，包含但不限于 Failover Cluster、Failfast Cluster 和 Failsafe Cluster 等。 主要调用阶段 在服务消费者初始化期间，集群 Cluster 实现类为服务消费者创建 Cluster Invoker 实例，即上图中的 merge 操作 Directory保存了Invoker列表(其实现类 RegistryDirectory 是一个动态服务目录，可感知注册中心配置的变化，它所持有的 Invoker 列表会随着注册中心内容的变化而变化；通过 LoadBalance 从 Invoker 列表中选择一个 Invoker 有了invoker后执行invoke方法完成最后的调用 容错方式 Failover Cluster - 失败自动切换（默认） Failfast Cluster - 快速失败 Failsafe Cluster - 失败安全 Failback Cluster - 失败自动恢复 Forking Cluster - 并行调用多个服务提供者 FailoverClusterInvoker doInvoke(选择invoker，执行invoke调用) FailoverClusterInvoker 的 doInvoke 方法首先是获取重试次数，然后根据重试次数进行循环调用，失败后进行重试。在 for 循环内，首先是通过负载均衡组件选择一个 Invoker，然后再通过这个 Invoker 的 invoke 方法进行远程调用。如果失败了，记录下异常，并进行重试。重试时会再次调用父类的 list 方法列举 Invoker public class FailoverClusterInvoker extends AbstractClusterInvoker { // 省略部分代码 @Override public Result doInvoke(Invocation invocation, final List> invokers, LoadBalance loadbalance) throws RpcException { List> copyinvokers = invokers; checkInvokers(copyinvokers, invocation); // 获取重试次数 int len = getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1; if (len > invoked = new ArrayList>(copyinvokers.size()); Set providers = new HashSet(len); // 循环调用，失败重试 for (int i = 0; i 0) { checkWhetherDestroyed(); // 在进行重试前重新列举 Invoker，这样做的好处是，如果某个服务挂了， // 通过调用 list 可得到最新可用的 Invoker 列表 copyinvokers = list(invocation); // 对 copyinvokers 进行判空检查 checkInvokers(copyinvokers, invocation); } // 通过负载均衡选择 Invoker Invoker invoker = select(loadbalance, invocation, copyinvokers, invoked); // 添加到 invoker 到 invoked 列表中 invoked.add(invoker); // 设置 invoked 到 RPC 上下文中 RpcContext.getContext().setInvokers((List) invoked); try { // 调用目标 Invoker 的 invoke 方法 Result result = invoker.invoke(invocation); return result; } catch (RpcException e) { if (e.isBiz()) { throw e; } le = e; } catch (Throwable e) { le = new RpcException(e.getMessage(), e); } finally { providers.add(invoker.getUrl().getAddress()); } } // 若重试失败，则抛出异常 throw new RpcException(..., \"Failed to invoke the method ...\"); } } select(通过负载均衡选择invoker) protected Invoker select(LoadBalance loadbalance, Invocation invocation, List> invokers, List> selected) throws RpcException { if (invokers == null || invokers.isEmpty()) return null; // 获取调用方法名 String methodName = invocation == null ? \"\" : invocation.getMethodName(); // 获取 sticky 配置，sticky 表示粘滞连接。所谓粘滞连接是指让服务消费者尽可能的 // 调用同一个服务提供者，除非该提供者挂了再进行切换 boolean sticky = invokers.get(0).getUrl().getMethodParameter(methodName, Constants.CLUSTER_STICKY_KEY, Constants.DEFAULT_CLUSTER_STICKY); { // 检测 invokers 列表是否包含 stickyInvoker，如果不包含， // 说明 stickyInvoker 代表的服务提供者挂了，此时需要将其置空 if (stickyInvoker != null && !invokers.contains(stickyInvoker)) { stickyInvoker = null; } // 在 sticky 为 true，且 stickyInvoker != null 的情况下。如果 selected 包含 // stickyInvoker，表明 stickyInvoker 对应的服务提供者可能因网络原因未能成功提供服务。 // 但是该提供者并没挂，此时 invokers 列表中仍存在该服务提供者对应的 Invoker。 if (sticky && stickyInvoker != null && (selected == null || !selected.contains(stickyInvoker))) { // availablecheck 表示是否开启了可用性检查，如果开启了，则调用 stickyInvoker 的 // isAvailable 方法进行检查，如果检查通过，则直接返回 stickyInvoker。 if (availablecheck && stickyInvoker.isAvailable()) { return stickyInvoker; } } } // 如果线程走到当前代码处，说明前面的 stickyInvoker 为空，或者不可用。 // 此时继续调用 doSelect 选择 Invoker Invoker invoker = doSelect(loadbalance, invocation, invokers, selected); // 如果 sticky 为 true，则将负载均衡组件选出的 Invoker 赋值给 stickyInvoker if (sticky) { stickyInvoker = invoker; } return invoker; } doSelect 主要做了两件事，第一是通过负载均衡组件选择 Invoker。第二是，如果选出来的 Invoker 不稳定，或不可用，此时需要调用 reselect 方法进行重选。若 reselect 选出来的 Invoker 为空，此时定位 invoker 在 invokers 列表中的位置 index，然后获取 index + 1 处的 invoker，这也可以看做是重选逻辑的一部分。 private Invoker doSelect(LoadBalance loadbalance, Invocation invocation, List> invokers, List> selected) throws RpcException { if (invokers == null || invokers.isEmpty()) return null; if (invokers.size() == 1) return invokers.get(0); if (loadbalance == null) { // 如果 loadbalance 为空，这里通过 SPI 加载 Loadbalance，默认为 RandomLoadBalance loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(Constants.DEFAULT_LOADBALANCE); } // 通过负载均衡组件选择 Invoker Invoker invoker = loadbalance.select(invokers, getUrl(), invocation); // 如果 selected 包含负载均衡选择出的 Invoker，或者该 Invoker 无法经过可用性检查，此时进行重选 if ((selected != null && selected.contains(invoker)) || (!invoker.isAvailable() && getUrl() != null && availablecheck)) { try { // 进行重选 Invoker rinvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck); if (rinvoker != null) { // 如果 rinvoker 不为空，则将其赋值给 invoker invoker = rinvoker; } else { // rinvoker 为空，定位 invoker 在 invokers 中的位置 int index = invokers.indexOf(invoker); try { // 获取 index + 1 位置处的 Invoker，以下代码等价于： // invoker = invokers.get((index + 1) % invokers.size()); invoker = index 负载均衡 负载均衡 RandomLoadBalance（随机加权，默认使用） RandomLoadBalance是加权随机算法的具体实现，它的算法思想很简单。假设我们有一组服务器 servers = [A, B, C]，他们对应的权重为 weights = [5, 3, 2]，权重总和为10。现在把这些权重值平铺在一维坐标值上，[0, 5) 区间属于服务器 A，[5, 8) 区间属于服务器 B，[8, 10) 区间属于服务器 C。接下来通过随机数生成器生成一个范围在 [0, 10) 之间的随机数，然后计算这个随机数会落到哪个区间上。比如数字3会落到服务器 A 对应的区间上，此时返回服务器 A 即可。权重越大的机器，在坐标轴上对应的区间范围就越大，因此随机数生成器生成的数字就会有更大的概率落到此区间内。只要随机数生成器产生的随机数分布性很好，在经过多次选择后，每个服务器被选中的次数比例接近其权重比例。比如，经过一万次选择后，服务器 A 被选中的次数大约为5000次，服务器 B 被选中的次数约为3000次，服务器 C 被选中的次数约为2000次。 public class RandomLoadBalance extends AbstractLoadBalance { public static final String NAME = \"random\"; private final Random random = new Random(); @Override protected Invoker doSelect(List> invokers, URL url, Invocation invocation) { int length = invokers.size(); int totalWeight = 0; boolean sameWeight = true; // 下面这个循环有两个作用，第一是计算总权重 totalWeight， // 第二是检测每个服务提供者的权重是否相同 for (int i = 0; i 0 && weight != getWeight(invokers.get(i - 1), invocation)) { sameWeight = false; } } // 下面的 if 分支主要用于获取随机数，并计算随机数落在哪个区间上 if (totalWeight > 0 && !sameWeight) { // 随机获取一个 [0, totalWeight) 区间内的数字 int offset = random.nextInt(totalWeight); // 循环让 offset 数减去服务提供者权重值，当 offset 小于0时，返回相应的 Invoker。 // 举例说明一下，我们有 servers = [A, B, C]，weights = [5, 3, 2]，offset = 7。 // 第一次循环，offset - 5 = 2 > 0，即 offset > 5， // 表明其不会落在服务器 A 对应的区间上。 // 第二次循环，offset - 3 = -1 LeastActiveLoadBalance（最小活跃数） LeastActiveLoadBalance翻译过来是最小活跃数负载均衡。活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求。此时应优先将请求分配给该服务提供者。在具体实现中，每个服务提供者对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为0。每收到一个请求，活跃数加1，完成请求后则将活跃数减1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。 ConsistentHashLoadBalance（一致性 hash） 一致性 hash 算法由麻省理工学院的 Karger 及其合作者于1997年提出的，算法提出之初是用于大规模缓存系统的负载均衡。 RoundRobinLoadBalance（轮询） 所谓轮询是指将请求轮流分配给每台服务器。举个例子，我们有三台服务器 A、B、C。我们将第一个请求分配给服务器 A，第二个请求分配给服务器 B，第三个请求分配给服务器 C，第四个请求再次分配给服务器 A。这个过程就叫做轮询。轮询是一种无状态负载均衡算法，实现简单，适用于每台服务器性能相近的场景下。但现实情况下，我们并不能保证每台服务器性能均相近。如果我们将等量的请求分配给性能较差的服务器，这显然是不合理的。因此，这个时候我们需要对轮询过程进行加权，以调控每台服务器的负载。经过加权后，每台服务器能够得到的请求数比例，接近或等于他们的权重比。比如服务器 A、B、C 权重比为 5:2:1。那么在8次请求中，服务器 A 将收到其中的5次请求，服务器 B 会收到其中的2次请求，服务器 C 则收到其中的1次请求。 Dubbo 通信协议和序列化 通信协议 Dubbo支持dubbo、rmi、hessian、http、webservice、thrift、redis等多种协议，但是Dubbo官网是推荐我们使用Dubbo协议的，默认也是用的dubbo协议。 doubbo协议 默认就是走 dubbo 协议，单一长连接，进行的是 NIO 异步通信，基于 hessian 作为序列化协议。使用的场景是：传输数据量小（每次请求在 100kb 以内），但是并发量很高。 rmi 协议 走 Java 二进制序列化，多个短连接，适合消费者和提供者数量差不多的情况，适用于文件的传输，一般较少用。 hessian 协议 走 hessian 序列化协议，多个短连接，适用于提供者数量比消费者数量还多的情况，适用于文件的传输，一般较少用。 http 协议 走 json 序列化。 webservice 走 SOAP 文本 序列化协议 java.io.Serializable Hessian, Hessian2 google protobuf facebook thrift kyro fst Json序列化框架：Jackson, gson, fastjson xml ... 2.7.5特性 Dubbo 当前支持的序列化包括 Json、Hessian2、Kryo、FST、Java 等，而这其中支持跨语言的只有 Json、Hessian2，通用的 Json 有固有的性能问题，而 Hessian2 无论在效率还是多语言 SDK 方面都有所欠缺。为此，Dubbo 通过支持 Protobuf 序列化来提供更高效、易用的跨语言序列化方案。 ProtoBuf性能好主要得益于：第一，它使用 proto 编译器，自动进行序列化和反序列化，速度非常快，应该比 XML 和 JSON 快上了 20~100 倍；第二，它的数据压缩效果好，就是说它序列化后的数据量体积小。因为体积小，传输起来带宽和速度上会有优化。 服务降级 服务降级：当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。 可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。 mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。 熔断处理： 限流 超时处理 资源隔离：限制特定consumer 服务降级：切换降级处理 级联失败(cascading failure)，涟漪，关键路径，最长路径 常见面试题 Dubbo内置了哪几种服务容器？ Spring Container Jetty Container Log4j Container Dubbo 的服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。 Dubbo默认使用什么注册中心，还有别的选择吗？ 推荐使用 Zookeeper 作为注册中心，还有 Redis、Multicast、Simple 注册中心，但不推荐。 Dubbo 核心的配置有哪些？ 标签 用途 解释 服务配置 用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心 引用配置 用于创建一个远程服务代理，一个引用可以指向多个注册中心 协议配置 用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受 应用配置 用于配置当前应用信息，不管该应用是提供者还是消费者 模块配置 用于配置当前模块信息，可选 注册中心配置 用于配置连接注册中心相关信息 监控中心配置 用于配置连接监控中心相关信息，可选 提供方配置 当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选 消费方配置 当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选 方法配置 用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息 参数配置 用于指定方法参数配置 配置覆盖关系? 以 timeout 为例，显示了配置的查找顺序，其它 retries, loadbalance, actives 等类似： 方法级优先，接口级次之，全局配置再次之。 如果级别一样，则消费方优先，提供方次之。 其中，服务提供方配置，通过 URL 经由注册中心传递给消费方。 建议由服务提供方设置超时，因为一个方法需要执行多长时间，服务提供方更清楚，如果一个消费方同时引用多个服务，就不需要关心每个服务的超时设置。 理论上 ReferenceConfig 的非服务标识配置，在 ConsumerConfig，ServiceConfig, ProviderConfig 均可以缺省配置。 在 Provider 上可以配置的 Consumer 端的属性有哪些？ timeout：方法调用超时 retries：失败重试次数，默认重试 2 次 loadbalance：负载均衡算法，默认随机 actives 消费者端，最大并发调用限制 Dubbo启动时如果依赖的服务不可用会怎样？ Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，默认 check=\"true\"，可以通过 check=\"false\" 关闭检查。 注册了多个同一样的服务，如果测试指定的某一个服务呢？ 可以配置环境点对点直连，绕过注册中心，将以服务接口为单位，忽略注册中心的提供者列表。 Dubbo服务之间的调用是阻塞的吗？ 默认是同步等待结果阻塞的，支持异步调用。 Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。 服务提供者能实现失效踢出是什么原理？ 服务失效踢出基于 Zookeeper 的临时节点原理。 服务读写推荐的容错策略是怎样的？ 读操作建议使用 Failover 失败自动切换，默认重试两次其它服务器。 写操作建议使用 Failfast 快速失败，发一次调用失败就立即报错。 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2021-02-11 13:12:48 "},"doc/provider_service.html":{"url":"doc/provider_service.html","title":"服务导出","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 服务导出 dubbo 服务导出 服务怎么导出的？ 源码导出流程图 源码走读 ServiceBean 发布事件 telnet 服务调用 dubbo服务本地发布，远程发布的原因 服务导出 dubbo 服务导出 Dubbo 服务导出过程始于 Spring 容器发布刷新事件，Dubbo 在接收到事件后，会立即执行服务导出逻辑。整个逻辑大致可分为三个部分 第一部分是前置工作，主要用于检查参数，组装 URL。 第二部分是导出服务，包含导出服务到本地 (JVM)，和导出服务到远程两个过程。 第三部分是向注册中心注册服务，用于服务发现。 服务怎么导出的？ dubbo会在Spring实例化bean之后，在刷新容器最后一步发布ContextRefreshEvent事件的时候，通知实现了ApplicationListener的ServiceBean类进行回调onApplicationEvent事件方法，dubbo会在这个方法中调用ServiceBean父类ServiceConfig的export方法，该方法真正实现服务的(异步或者非异步)发布 暴露本地服务 暴露远程服务 启动netty 连接zookeeper 到zookeeper注册 监听zookeeper 首先 ServiceConfig 类拿到对外提供服务的实际类 ref(如：HelloWorldImpl),然后通过 ProxyFactory 类的 getInvoker方法使用 ref 生成一个 AbstractProxyInvoker 实例，到这一步就完成具体服务到 Invoker 的转化。 接下来就是 Invoker 转换到 Exporter 的过程。Dubbo 处理服务暴露的关键就在 Invoker 转换到 Exporter 的过程，上图中的红色部分。 Dubbo 的实现 Dubbo 协议的 Invoker 转为 Exporter 发生在 DubboProtocol 类的 export 方法，它主要是打开 socket 侦听服务，并接收客户端发来的各种请求，通讯细节由 Dubbo 自己实现。 源码导出流程图 源码走读 DubboBeanDefinitionParser implements BeanDefinitionParser解析xml中的dubbo标签，生成BeanDefinition org.apache.dubbo.config.spring.schema.DubboNamespaceHandler 注解方式则是ServiceClassPostProcessor类负责将带有org.apache.dubbo.config.annotation.Service注解的类注册为普通的 bean 和 ServiceBean public class ServiceClassPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware, ResourceLoaderAware, BeanClassLoaderAware { ServiceBean 发布事件 public class ServiceBean extends ServiceConfig implements InitializingBean, DisposableBean, ApplicationContextAware, BeanNameAware, ApplicationEventPublisherAware { 在ServiceBean发布了ServiceBeanExportedEvent事件 public class ServiceBeanExportedEvent extends ApplicationEvent { /** * Create a new ApplicationEvent. * * @param serviceBean {@link ServiceBean} bean */ public ServiceBeanExportedEvent(ServiceBean serviceBean) { super(serviceBean); } /** * Get {@link ServiceBean} instance * * @return non-null */ public ServiceBean getServiceBean() { return (ServiceBean) super.getSource(); } } ServiceConfig导出服务 org.apache.dubbo.config.ServiceConfig#doExportUrls 定义了多少个协议，就导出多少次，可以向多个注册中心注册 导出到哪里，比如zookeeper，如下可以到registry 导出本地缓存 导出远程zk，代理 Invoker invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString())); DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this); Exporter exporter = PROTOCOL.export(wrapperInvoker); exporters.add(exporter); PROTOCOL.export(wrapperInvoker)走到 org.apache.dubbo.registry.integration.RegistryProtocol#export //export invoker final ExporterChangeableWrapper exporter = doLocalExport(originInvoker, providerUrl); 继续走到org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#export 需要创建服务createServer(url) private void openServer(URL url) { // find server. String key = url.getAddress(); //client can export a service which's only for server to invoke boolean isServer = url.getParameter(IS_SERVER_KEY, true); if (isServer) { ProtocolServer server = serverMap.get(key); if (server == null) { synchronized (this) { server = serverMap.get(key); if (server == null) { serverMap.put(key, createServer(url)); } } } else { // server supports reset, use together with override server.reset(url); } } } createServer默认netty url: dubbo://192.168.1.3:20880/org.apache.dubbo.demo.DemoService?anyhost=true&application=demo-provider&bind.ip=192.168.1.3&bind.port=20880&channel.readonly.sent=true&codec=dubbo&deprecated=false&dubbo=2.0.2&dynamic=true&generic=false&heartbeat=60000&interface=org.apache.dubbo.demo.DemoService&metadata-type=remote&methods=sayHello,sayHelloAsync&pid=70345&qos.port=22222&release=&side=provider&timestamp=1606142890163 private ProtocolServer createServer(URL url) { url = URLBuilder.from(url) // send readonly event when server closes, it's enabled by default .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString()) // enable heartbeat by default .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT)) .addParameter(CODEC_KEY, DubboCodec.NAME) .build(); String str = url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER); if (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) { throw new RpcException(\"Unsupported server type: \" + str + \", url: \" + url); } ExchangeServer server; try { server = Exchangers.bind(url, requestHandler); } catch (RemotingException e) { throw new RpcException(\"Fail to start server(url: \" + url + \") \" + e.getMessage(), e); } str = url.getParameter(CLIENT_KEY); if (str != null && str.length() > 0) { Set supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(); if (!supportedTypes.contains(str)) { throw new RpcException(\"Unsupported client type: \" + str); } } return new DubboProtocolServer(server); } 开始绑定 public static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException { if (url == null) { throw new IllegalArgumentException(\"url == null\"); } if (handler == null) { throw new IllegalArgumentException(\"handler == null\"); } url = url.addParameterIfAbsent(Constants.CODEC_KEY, \"exchange\"); return getExchanger(url).bind(url, handler); } 走到org.apache.dubbo.remoting.Transporters#bind public static RemotingServer bind(URL url, ChannelHandler... handlers) throws RemotingException { if (url == null) { throw new IllegalArgumentException(\"url == null\"); } if (handlers == null || handlers.length == 0) { throw new IllegalArgumentException(\"handlers == null\"); } ChannelHandler handler; if (handlers.length == 1) { handler = handlers[0]; } else { handler = new ChannelHandlerDispatcher(handlers); } return getTransporter().bind(url, handler); } 最后使用netty服务 telnet 服务调用 mubi@mubideMacBook-Pro ~ $ telnet 192.168.1.3 20880 Trying 192.168.1.3... Connected to 192.168.1.3. Escape character is '^]'. ^] telnet> dubbo>ls PROVIDER: org.apache.dubbo.demo.DemoService dubbo>ls org.apache.dubbo.demo.DemoService org.apache.dubbo.demo.DemoService (as provider): sayHello sayHelloAsync dubbo>invoke org.apache.dubbo.demo.DemoService.sayHello('aaa') Use default service org.apache.dubbo.demo.DemoService. result: \"Hello aaa, response from provider: null\" elapsed: 1014 ms. dubbo> dubbo服务本地发布，远程发布的原因 为什么会有本地暴露和远程暴露呢?不从场景考虑讨论技术的没有意义是.在dubbo中我们一个服务可能既是Provider,又是Consumer,因此就存在他自己调用自己服务的情况,如果再通过网络去访问,那自然是舍近求远,因此他是有本地暴露服务的这个设计.从这里我们就知道这个两者的区别 本地暴露是暴露在JVM中,不需要网络通信 远程暴露是将ip,端口等信息暴露给远程客户端,调用时需要网络通信 如果协议为本地协议(injvm)，则表示不向注册中心注册服务，在map中存储键为notify,值为false,表示当注册中心监听到服务提供者发送变化（服务提供者增加、服务提供者减少等事件）时不通知。 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-12-26 11:35:45 "},"doc/invoke_service.html":{"url":"doc/invoke_service.html","title":"服务引用","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 服务引用(消费者启动) 源码走读 服务引用(消费者启动) 服务引用的目的：服务消费者向注册中心订阅服务提供者提供的服务地址，并生成服务接口的实际代理对象。 把服务引用的信息封装成URL并注册到zk注册中心; 监听注册中心的服务的上下线; 连接服务提供端，创建NettyClient对象; 将这些信息包装成DubboInvoker消费端的调用链，创建消费端Invoker实例的服务代理并返回; 源码走读 org.apache.dubbo.config.spring.schema.DubboNamespaceHandler#init org.apache.dubbo.config.ReferenceConfig#createProxy org.apache.dubbo.registry.integration.RegistryProtocol#refer org.apache.dubbo.registry.integration.RegistryProtocol.doRefer private Invoker doRefer(Cluster cluster, Registry registry, Class type, URL url) { //构建RegistryDirectory,可以把它理解为注册资源,其中包含了消费者/服务/路由等相关信息 //其同时也是回调监听器 RegistryDirectory directory = new RegistryDirectory(type, url); directory.setRegistry(registry); directory.setProtocol(protocol); URL subscribeUrl = new URL(Constants.CONSUMER_PROTOCOL, NetUtils.getLocalHost(), 0, type.getName(), directory.getUrl().getParameters()); if (!Constants.ANY_VALUE.equals(url.getServiceInterface()) && url.getParameter(Constants.REGISTER_KEY, true)) { //向注册中心注册服务消费者 registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY, Constants.CHECK_KEY, String.valueOf(false))); } // 从注册中心订阅服务提供者（即引用的服务） directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY + \",\" + Constants.CONFIGURATORS_CATEGORY + \",\" + Constants.ROUTERS_CATEGORY)); // return cluster.join(directory); } url:consumer://172.28.101.52/org.apache.dubbo.demo.DemoService?application=demo-consumer&category=consumers&check=false&dubbo=2.0.2&init=false&interface=org.apache.dubbo.demo.DemoService&metadata-type=remote&methods=sayHello,sayHelloAsync&pid=75487&qos.port=33333&side=consumer&sticky=false&timestamp=1606215560930 zk上可以看到注册的consumer org.apache.dubbo.registry.integration.RegistryDirectory#subscribe 注册监听服务 org.apache.dubbo.rpc.proxy.javassist.JavassistProxyFactory#getProxy 创建代理 public class JavassistProxyFactory extends AbstractProxyFactory { @Override @SuppressWarnings(\"unchecked\") public T getProxy(Invoker invoker, Class[] interfaces) { return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker)); } @Override public Invoker getInvoker(T proxy, Class type, URL url) { // TODO Wrapper cannot handle this scenario correctly: the classname contains '$' final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') (proxy, type, url) { @Override protected Object doInvoke(T proxy, String methodName, Class[] parameterTypes, Object[] arguments) throws Throwable { return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments); } }; } } org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol#protocolBindingRefer 建立连接 /** * Create new connection * * @param url */ private ExchangeClient initClient(URL url) { // client type setting. String str = url.getParameter(CLIENT_KEY, url.getParameter(SERVER_KEY, DEFAULT_REMOTING_CLIENT)); url = url.addParameter(CODEC_KEY, DubboCodec.NAME); // enable heartbeat by default url = url.addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT)); // BIO is not allowed since it has severe performance issue. if (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) { throw new RpcException(\"Unsupported client type: \" + str + \",\" + \" supported client type is \" + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), \" \")); } ExchangeClient client; try { // connection should be lazy if (url.getParameter(LAZY_CONNECT_KEY, false)) { client = new LazyConnectExchangeClient(url, requestHandler); } else { client = Exchangers.connect(url, requestHandler); } } catch (RemotingException e) { throw new RpcException(\"Fail to create remoting client for service(\" + url + \"): \" + e.getMessage(), e); } return client; } 进入org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger#connect 接着进入org.apache.dubbo.remoting.Transporters#connect public static Client connect(URL url, ChannelHandler... handlers) throws RemotingException { if (url == null) { throw new IllegalArgumentException(\"url == null\"); } ChannelHandler handler; if (handlers == null || handlers.length == 0) { handler = new ChannelHandlerAdapter(); } else if (handlers.length == 1) { handler = handlers[0]; } else { handler = new ChannelHandlerDispatcher(handlers); } return getTransporter().connect(url, handler); } 最终得到的是代理对象 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-12-26 11:37:51 "},"doc/consumer.html":{"url":"doc/consumer.html","title":"服务调用","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 服务调用 源码流程 服务调用 源码流程 执行：invoker.invoke(rpcInvocation).recreate(); 进入到org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker#invoke @Override public Result invoke(final Invocation invocation) throws RpcException { checkWhetherDestroyed(); // binding attachments into invocation. Map contextAttachments = RpcContext.getContext().getObjectAttachments(); if (contextAttachments != null && contextAttachments.size() != 0) { ((RpcInvocation) invocation).addObjectAttachments(contextAttachments); } List> invokers = list(invocation); LoadBalance loadbalance = initLoadBalance(invokers, invocation); RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation); return doInvoke(invocation, invokers, loadbalance); } 默认loadbalance是RandomLoadBalance 服务容错，默认FailoverClusterInvoker public class FailoverClusterInvoker extends AbstractClusterInvoker { private static final Logger logger = LoggerFactory.getLogger(FailoverClusterInvoker.class); public FailoverClusterInvoker(Directory directory) { super(directory); } @Override @SuppressWarnings({\"unchecked\", \"rawtypes\"}) public Result doInvoke(Invocation invocation, final List> invokers, LoadBalance loadbalance) throws RpcException { List> copyInvokers = invokers; checkInvokers(copyInvokers, invocation); String methodName = RpcUtils.getMethodName(invocation); int len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + 1; if (len > invoked = new ArrayList>(copyInvokers.size()); // invoked invokers. Set providers = new HashSet(len); for (int i = 0; i 0) { checkWhetherDestroyed(); copyInvokers = list(invocation); // check again checkInvokers(copyInvokers, invocation); } // 根据负载均衡得到执行对象 Invoker invoker = select(loadbalance, invocation, copyInvokers, invoked); invoked.add(invoker); RpcContext.getContext().setInvokers((List) invoked); try { Result result = invoker.invoke(invocation); if (le != null && logger.isWarnEnabled()) { logger.warn(\"Although retry the method \" + methodName + \" in the service \" + getInterface().getName() + \" was successful by the provider \" + invoker.getUrl().getAddress() + \", but there have been failed providers \" + providers + \" (\" + providers.size() + \"/\" + copyInvokers.size() + \") from the registry \" + directory.getUrl().getAddress() + \" on the consumer \" + NetUtils.getLocalHost() + \" using the dubbo version \" + Version.getVersion() + \". Last error is: \" + le.getMessage(), le); } return result; } catch (RpcException e) { if (e.isBiz()) { // biz exception. throw e; } le = e; } catch (Throwable e) { le = new RpcException(e.getMessage(), e); } finally { providers.add(invoker.getUrl().getAddress()); } } throw new RpcException(le.getCode(), \"Failed to invoke the method \" + methodName + \" in the service \" + getInterface().getName() + \". Tried \" + len + \" times of the providers \" + providers + \" (\" + providers.size() + \"/\" + copyInvokers.size() + \") from the registry \" + directory.getUrl().getAddress() + \" on the consumer \" + NetUtils.getLocalHost() + \" using the dubbo version \" + Version.getVersion() + \". Last error is: \" + le.getMessage(), le.getCause() != null ? le.getCause() : le); } } 同步方法调用会进入AsyncToSyncInvoker org.apache.dubbo.rpc.protocol.dubbo.DubboInvoker#doInvoke @Override protected Result doInvoke(final Invocation invocation) throws Throwable { RpcInvocation inv = (RpcInvocation) invocation; final String methodName = RpcUtils.getMethodName(invocation); inv.setAttachment(PATH_KEY, getUrl().getPath()); inv.setAttachment(VERSION_KEY, version); ExchangeClient currentClient; if (clients.length == 1) { currentClient = clients[0]; } else { currentClient = clients[index.getAndIncrement() % clients.length]; } try { boolean isOneway = RpcUtils.isOneway(getUrl(), invocation); int timeout = calculateTimeout(invocation, methodName); if (isOneway) { boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false); currentClient.send(inv, isSent); return AsyncRpcResult.newDefaultAsyncResult(invocation); } else { ExecutorService executor = getCallbackExecutor(getUrl(), inv); // 发起网络请求，获取结果 CompletableFuture appResponseFuture = currentClient.request(inv, timeout, executor).thenApply(obj -> (AppResponse) obj); // save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter FutureContext.getContext().setCompatibleFuture(appResponseFuture); AsyncRpcResult result = new AsyncRpcResult(appResponseFuture, inv); result.setExecutor(executor); return result; } } catch (TimeoutException e) { throw new RpcException(RpcException.TIMEOUT_EXCEPTION, \"Invoke remote method timeout. method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e); } catch (RemotingException e) { throw new RpcException(RpcException.NETWORK_EXCEPTION, \"Failed to invoke remote method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e); } } 最后得到返回结果 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-12-26 10:11:09 "},"doc/generic_consumer.html":{"url":"doc/generic_consumer.html","title":"泛化调用","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 泛化调用 dubbo 泛化调用客户端例子代码 什么是泛化调用 泛化调用原理 泛化调用 dubbo 泛化调用客户端例子代码 服务端暴露泛化服务，客户端不需要做声明和jar引入，直接完成对特定泛化服务的调用 import org.apache.dubbo.config.ApplicationConfig; import org.apache.dubbo.config.ReferenceConfig; import org.apache.dubbo.config.RegistryConfig; import org.apache.dubbo.config.utils.ReferenceConfigCache; import org.apache.dubbo.rpc.service.GenericService; public class GenericApplication { public static void main(String[] args) { // 连接注册中心配置 RegistryConfig registry = new RegistryConfig(); registry.setAddress(\"zookeeper://127.0.0.1:2181\"); ReferenceConfig reference = new ReferenceConfig(); ApplicationConfig application = new ApplicationConfig(); application.setName(\"generic-consumer\"); reference.setApplication(application); reference.setRegistry(registry); reference.setInterface(\"org.apache.dubbo.demo.GreetingService\"); // 声明为泛化接口 reference.setGeneric(true); ReferenceConfigCache cache = ReferenceConfigCache.getCache(); GenericService genericService = cache.get(reference); // 直接调用 Object result = genericService.$invoke(\"hello\", new String[] { \"java.lang.String\" }, new Object[] { \"world\" }); System.out.println(result); } } 什么是泛化调用 相对于需要依赖业务客户端JAR包的正常调用，泛化调用不需要依赖二方包，使用其特定的GenericService接口，传入需要调用的方法名、方法签名和参数值进行调用服务。 泛化调用适用于一些网关应用（没办法依赖所有服务的二方包） 泛化调用原理 客户端数据dubbo协议传递到服务端，服务端GenericFilter要完成实际的方法名，参数类型，参数的提取并反序列化城POJO对对象，并做各种校验工作 最后仍然是代理+反射完成实际方法调用和返回 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2021-10-02 13:29:28 "}}